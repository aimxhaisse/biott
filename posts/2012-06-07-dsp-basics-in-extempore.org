#+BEGIN_HTML
---
layout: post
title: "DSP basics in extempore"
date: 2012-06-07 12:05
comments: false
categories: 
---
#+END_HTML

Hey folks,

This is the first post in a series which covers the programming
environment [[http://github.com/digego/extempore][extempore]], a real-time environment designed firstly for
live programming of music and visuals, but is actually a pretty great
platform for all sorts of programming tasks.  It's the successor to
[[http://impromptu.moso.com.au][impromptu]] - another live coding language - and it shares some features
with that project, but it also has a few key benefits:

- it's open source
- it's cross-platform (Linux, Mac OS X, Windows
- it has a [[http://llvm.org][LLVM]] backend for generating efficient machine code

* xtlang (it's not scheme)

This post covers some of the very basics of xtlang and its
potential for real-time digital signal processing (DSP). This isn't
necessarily the way you'd /do/ this if you wanted to just jump in and
make some noise (there are libraries which set up a lot of this stuff
for you), but it's a good chance to look under the hood and explain a
few key concepts.

Firstly, although this might all look like scheme, /it's not/.
Extempore actually hosts two languages: scheme, and xtlang. xtlang
looks a lot like scheme with type annotations, but it also includes
the ability to basically write C with s-expressions. This means that
in xtlang you have the low-level 'close to the metal' control (and
associated performance) of a language like C, but you can also use
functional things like closures, map/reduce and first-class functions.

I'll put up a heap more tutorials in the coming months explaining the
details of how it all works, but for the moment just remember that
there are some crucial differences (mostly to do with static typing)
between the scheme parts of the code and the xtlang parts.

To give an example of what I'm talking about, consider this basic
xtlang function:

#+begin_src extempore
(bind-func my-test-1
  (lambda (a)
    (* a 5)))
#+end_src

It looks a whole lot like a regular scheme function, except that
instead of using =define= to create the closure we use =bind-func=.
That's the key that this is an xtlang function and not a
scheme one (scheme functions in extempore still use define as
normal).

When this function is JIT-compiled (by sending it to the running
extempore process), the compiler prints the type signature - in this
case =[i64,i64]*=. It's worth breaking this down a bit: the trailing
=*= indicates that =bind-func= returns a pointer. The square brackets
(=[]=) indicate that this is a pointer to a [[http://en.wikipedia.org/wiki/Closure_(computer_science)][closure]], and the types
/inside/ the square brackets indicate the type signature of this
closure. The first type (=i64=) is the type of the return value, while
any subsequent types (in this case one =i64=) are the types of the
arguments, so it's just like an s-expression.

* Type inferencing in the xtlang compiler

So how did the compiler figure out what the return and argument types
would be for this function?  The answer is through the number '5' in
the body of the function (called an /integer literal/).  Although the
integer 5 can be represented by any of the recognised int types
(except =i1=, which can only hold a 0 or 1), by default the extempore
compiler treats integers as =i64= unless you explicitly tell it
otherwise.  Similarly, /float literals/ are interpreted as doubles, so

#+begin_src extempore
(bind-func my-test-2
  (lambda (a)
    (* a 5.0)))
#+end_src

would have the type signature =[double,double]*=: a pointer to a
closure which takes a double and returns a double. The xtlang
compiler will only infer types like this if the type information is
unambiguous, so if there are /no/ variables in the function which the
compiler is not already aware of (or integer/float literals which are
read as =i64= / =double=) 

#+begin_src extempore
(bind-func my-test-3
  (lambda (a b)
    (/ a b)))
#+end_src

then the compiler will throw an error: 

#+begin_html
```
Compiler Error: could not resolve ("a" "b" "my-test-3") you could
try forcing the type of one or more of these symbols.
```
#+end_html

As the compiler suggests, what we need to do
is to explicitly provide some type information:

#+begin_src extempore
(bind-func my-test-4
  (lambda (a:double b)
    (/ a b)))
#+end_src

We didn't need to type /both/ =a= and =b= as =double= (although
there's no harm in doing so), having the type of one or the other is
enough to infer the type of the return value, which is the result of
the division (=/=) function.

This type signature stuff is important: everything is statically typed
in xtlang, and the compiler does no implicit casts for you (it does do
type /inferencing/ when it's unambiguous, but that's not the same
thing). You can see how xtlang gives us the power to 'write C in
scheme' if we want to, but we also still have /scheme/ if we want to
write in scheme.

Extempore supports all the basic int and float types (=double=, =i32=,
etc.) as well as combinations thereof, including tuples, arrays and
even generics. But that's all stuff for another day - for the moment
the key thing to remember is that this type signature tells us the
types of the arguments and return value of =my-test-1=. If we try and
call it with arguments of the wrong types, it'll throw an error.

* Closures: poking around in the environment

Now, a point about the compiler returning /closures/ rather than just
functions: a closure is a function along with any non-local variables
which were bound in its environment. So if we have a function which
'closes over' some other variable outside its scope, then that
variable is captured in the function closure:

#+begin_src extempore
(bind-func my-test-5
  (let ((nonlocal-var 0))
    (lambda (x)
      (set! nonlocal-var (+ nonlocal-var 1))
      (* x nonlocal-var))))
#+end_src

The variable =nonlocal-var= is bound outside the function scope in the
surrounding =let=, but because it occurs in the body of the function
(as a multiplier in the return value) then the closure contains a
reference to =nonlocal-var=. This is nice because it allows us to have
some persistent state between successive calls to the function
=my-test-5=, which will return:

#+begin_src extempore
(println (my-test-2 2)) ;; will print 2
(println (my-test-2 2)) ;; will print 4
(println (my-test-2 2)) ;; will print 6, etc.
#+end_src

xtlang even provides a nice 'dot syntax' for accessing (and
mutating) the closed-over variables in a closure's environment.

Like scheme, then, xtlang is not a pure functional language.
But this allows us to do some pretty cool stuff, particularly when we
start to make some noise.

* Making a sound: real-time DSP

So, how does this all relate to making cool sounds? Well, extempore
uses xtlang for dynamic, hot-swappable DSP code. There is a special
function in the environment called (funnily enough) =dsp=. This
function is the audio output 'sink' - the value returned by this
function is (basically) written directly to the audio driver and
output as sound through the computer speakers. Every audio sample
(that is, at a rate of 44100Hz) this function is called with a few
arguments:

#+begin_src extempore
(bind-func dsp
  (lambda (in:double time:double chan:double data:double*)
    (sin (/ (* TWOPI 440.0 time)
          44100.0))))

; to let extempore know that this function is the one 
; it should call to get the output audio samples
(dsp:set! dsp)
#+end_src

This dsp takes as input three =double= s and a /pointer/ to a double: 
- =in=: the input audio sample, e.g. from the microphone
- =time=: a double value representing the time
- =chan=: another double which represents the channel index (0 for L,
  1 for R, etc.).  Extempore can handle any number of channels.
- =data=: this is a /pointer/ to a double, and can be used to pass
  arbitrary data into the dsp function.

In the example above, I'm ignoring all of these arguments except for
the =time= argument, which I'm using to generate a simple sinusoid at
440Hz.  But the cool thing is that like all functions in extempore,
this =dsp= function can be redefined on-the-fly (as long as the type
signature stays the same).  So, if I change the =dsp= function to:

#+begin_src extempore
(bind-func dsp
  (lambda (in:double time:double chan:double data:double*)
    (* 0.1 (random))))
#+end_src

then the output changes to white noise.  This is the real power of
xtlang (and extempore) - everything's dynamic and modifiable at
runtime, but it's also performant enough to do sample-level
manipulation in the same language and environment.  So instead of the
ugens (unit generators, e.g. oscillators) being locked up in a
different language to the control language, it's all mixed in
together.  

* Abstraction and higher-order functions

In fact, let's create some oscillators:

#+begin_src extempore
(bind-func make-osc
  (lambda (phase)
    (lambda (amp freq)
       (let ((inc (* TWOPI (/ freq 44100.0))))
             (set! phase (+ phase inc))
             (* amp (sin phase))))))
#+end_src

This =make-osc= function doesn't return a primitive (int/float)
value - it returns a (pointer to a) closure, which is our 'oscillator'
and takes an amplitude and a phase argument. This is represented by
the type message from the compiler when we evaluate =make-osc=, which
is =Compiled make-osc >>> [[double,double,double]*,double]*=. See that
the return type of the =make-osc= function is
=[double,double,double]*= a pointer to a closure which takes two
=double= arguments and returns a =double=. This is our oscillator, and
we can use our =make-osc= function to create as many oscillators as we
need:

#+begin_src extempore
(bind-func dsp
  (let ((osc1 (make-osc 0.0))
        (osc2 (make-osc 0.0)))
    (lambda (in:double time:double channel:double data:double*)
      (cond ; play a 200Hz tone in the left ear
            ((= channel 0.0) (osc1 0.5 200.0)) 
            ; play a 300Hz tone in the right ear
            ((= channel 1.0) (osc2 0.5 300.0))
            (else 0.0)))))
#+end_src

The =phase= variable in each of our oscillator closures is how we
maintain state between calls to =osc1= or =osc2=.  Each time the closure is
called, =phase= gets incremented (see the definition of =make-osc=
above), and because =phase= is bound within a let that is local to the
returned closure, each osc has its /own/ =phase= value, so the
oscillators created by =make-osc= are independent.  In the case above,
they are each called with different frequencies to produce sine tones
of different pitch for each ear.  This is closures in action, and it's
an example of how the 'scheme-like' aspect of xtlang can simplify the
job of maintaining state.

* This is not the end...

It doesn't take much imagination to see that /much/ cooler stuff can
be done in =dsp= than just playing two sine tones. AM synthesis, FM
synthesis, granular and wavetable synthesis, as well as sampling and
sample manipulation - these are all possible. I'll explain in future blog
posts how some of those things could be done in xtlang. Also, I
haven't even /touched/ on the graphics capabilities of extempore, but
I'll get a chance to cover those soon.
# If you can't wait, check the examples subdir of the [[http://github.com/digego/extempore][extempore github
# repo]] - lots of good stuff in there.

Also, I should point out that there are heaps better/easier ways to
achieve a lot of this stuff in extempore - syntactic sugar, library
support etc. If you're interested, jump on in and have a poke around,
or even fork it and contribute a patch. The docs are a bit sparse at
the moment, but I'm hoping that this blog post (and more that will
follow) will be a helpful resource for those starting out. And if you
/do/ make something cool, then throw it up on the interwebs and let me
know :)
