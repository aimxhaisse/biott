#+BEGIN_HTML
---
layout: post
title: "Memory management in Extempore"
date: 2012-08-17 10:49
comments: false
external-url: 
categories: 
---
#+END_HTML

The two languages hosted by the Extempore compiler, xtlang and Scheme,
have different approaches to dealing with memory allocation and
management.  Both languages ultimately share the same memory---the
stack and heap associated with the Extempore process, Extemore gives
access to this memory to both languages via different mechanisms.
Broadly speaking, with Scheme code Extempore manages memory for you,
while in xtlang you have to do it yourself.  This is a common
tradeoff, and each has its advantages (in performance, programmer
productivity, etc.) and disadvantages.  To work effectively in
Extempore it's helpful to know a bit more about how to work with
memory in Extempore, and that's what I'll try to cover in this post.

* Automatic garbage collection in Scheme

Scheme objects (lists, closures, numbers, etx.) are automatically
[[http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)][garbage collected]] by the Extempore runtime garbage collector (GC)[fn:gc].
This means that when new objects are created, memory is automatically
allocated to store those objects, and as objects are destroyed or go
out of scope (that is, there are no longer any references to them) the
memory is automatically freed up for re-use.  

Let's do the most basic memory allocation imaginable: just binding a
numerical value to a symbol.

#+begin_src extempore
  (define a 5)
  
  (println 'a '= a)  ;; prints a = 5
#+end_src

The fact that we can use the symbol =a= and have it evaluate to =5=
(as it should) means that the value (=5=) must be stored in memory
somewhere.[fn:memory] It doesn't matter /where/ in memory (what the
address is), because we can always refer to the value using the symbol
=a=. But it's good to remember that the =define= form is allocating
some memory, storing the value =5= in that memory, and binding a
reference to the value in the symbol =a=.

We can redefine the symbol =a= to be some other Scheme object, say, a list.

#+begin_src extempore
  (define a '(1 2 3))
  
  (println 'a '= a)  ;; prints a = (1 2 3)
#+end_src

The three-element list =(1 2 3)= takes up more memory than the number
=5=. So =define= can't just write the new value of =a= over the top of
the old one. What it does (and in fact what re-defining things
/always/ does) is allocate some new memory to store the new value
into, and change the variable =a= to point to that new value.

But what happens to the old value of =5= in memory? Well, it sits
there unmolested, at least for a while. But we can't reach it---the
only 'handle' we had to refer to it with was the symbol =a=, and
that's now bound to some other value instead. The value =5= in memory
is 'unreachable'. So there's no point having it sitting around, taking
up space like some freeloading relative.

That's where the garbage collector comes in. Every now and then the
garbage collector checks all the Scheme objects in the
world,[fn:world] determines which of them are no longer reachable, and
then frees up that memory to be used for other things. While this is a
harsh, utilitarian approach to dealing with relatives (and shows the
dangers of anthromorphising bit patterns in memory), it's a good idea
in a computer program. Memory is a finite resource, and the more
efficiently we can get rid of memory that's not being used the better.

Basically, having a GC means that when you're writing Scheme code, you
don't have to worry about memory. The GC takes care of all the
allocation/deallocation bookkeeping for you. The cost of this is that
every now and then the GC has to 'stop the world' (freeze the
execution of all Scheme code) to do its job. This takes time, and
introduces an element of uncertainty (nondeterminism) to the execution
of your code---you never know exactly when the GC is going to freeze
things to do it's job, and there's a risk that it'll happen at a
really inconvenient time as far as your program is concerned (Murphy's
law and all that). This is particularly problematic in domains where
timing is critical, such as real-time audio and video.

* Manual memory management in xtlang

# todo put accents in
Hang on a sec---isn't working with real-time audio and video
Extempore's /raison detre?/
When coding in xtlang, it's up to the programmer to request and manage
themselves 

zalloc, for zone allocated memory, is a kind of stack memory
allocation with user extent. Essentially this means that the end user
can push and pop zones off of a stack of memory zones of user defined
size.

When a new zone is created (pushed) any calls to zalloc will be
allocated from the new zone (being the *top* zone). When the extent of
the zone is reached it is *popped* and its memory is reclaimed. The
new *current* zone is then the next *top* zone. (i'm trying to talk
about a stack without using the word stack and confusing you with
salloc which is probably just confusing you even more :-)

A memory zone can be created by calling memzone with a zone size in
bytes. The extent of the zone is defined by memzone's s-expression.
Anything within the body of the memzone s-expression is *in* scope.

By default each process has an initial *top* zone with 1M of memory.
If no user defined zones are created (i.e. no uses of memzone) then
any and all calls to zalloc will slowly (or quickly) use up this 1M of
memory - you'll know when it runs out as you'll get about a gazillion
memory leak messages. In essence this is the zone story.

To complicate things slightly there are two special zones.

Firstly for audio. There is a zone allocated for each audio frame
processed, be that sample by sample, or buffer by buffer. The zones
extent is for the duration of the audio frame (i.e. is deallocated at
the end of the frame).

The second special case is that all "top level" closures (any closure
created using bind-func) has an associated zone created at compile
time (not at runtime, although this distinction is quite blurry in
extempore). The bind-func zone default is 1k, however, bind-func has
an optional argument to specify any arbitrary bind-func zone size.

This bind-func zone is very useful for holding data closed over by the
top level closure. For example, an audio delay closure might specify a
large bind-func zone size and then allocate an audio buffer to be
closed over. The audio-dsp.xtm has lots of examples of this.

The bind-func zone will live for the extent of the top level closure,
and will be refreshed if the closure is rebuilt (i.e. the old zone
will be destroyed and a new zone allocated).

memory zones are an extempore thing rather than an llvm thing if such
a distinction is useful.

#+begin_src extempore
  (bind-func dsp:DSP 1000000
             (let ((wavetable:|1000,double|* (alloc))
                   (i 0)
                   (b 0.0))
               (dotimes (i 1000)
                 (sin (* (* TWOPI (if (> 1 (i32toi64 700))
                                      (ftod 440.0)
                                      (ftod 660.0)))
                         (i64tod i)))
                 (aset! wavetable i 0.0))
               (lambda (in time chan data)
                 (let ((wavetable-ptr (modulo (dtoi64 time) 1000)))
                   (if (< (random) 0.01)
                       (aset! wavetable
                              wavetable-ptr
                              (+ (* 0.1 (random))
                                 (aref wavetable wavetable-ptr))))
                   (if (= chan 0.0)
                       (aref wavetable wavetable-ptr)
                       0.0)))))
#+end_src

[fn:gc] Extempore uses a mark-and-sweep garbage collector for those
who are into that sort of thing.

[fn:memory] [[file:2012-08-13-understanding-pointers-in-xtlang.org][This post]] covers in more detail how computers store data in
memory.

[fn:world] well, at least the world of your Extempore process, which
/is/ the world as far as the GC is concerned
