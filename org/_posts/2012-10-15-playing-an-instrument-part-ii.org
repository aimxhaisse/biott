#+begin_html
---
layout: post
title: "Playing an instrument part II"
date: 2012-10-15 11:23
comments: true
categories:
---
#+end_html

It may seem a little strange when you first come to Extempore that
there are no "musical" functions provided for you---this is a conscious
decision.  While it is impossible to provide a "tool" that does not in
some way influence its user, my goal with Extempore is to provide a
framework without any prescribed musical features.[fn:quarter-tone] Nevertheless my aim with Extempore is primarily to provide
a shell that takes care of the "low level" details and leaves the
creative/representational details to the user (as much as
practicable).
 
So with these thoughts in mind I want to stress that these music
tutorials show some ways of representing musical processes/data not
the way. For example, MIDI pitch numbers are certainly not the only
way to represent or control pitch in Extempore---you are just as free
to use a function to continuously control the Hz value of a Reaktor
patch parameter (as I often do). I designed Extempore so you don't
have to think about how to write scheduling engines and garbage
collectors---you do have to think about writing useful musical
processes/representations!
 
One last thing. Make sure you have read the Extempore basics tutorial
before you begin these tutorials.
 
So enough with the lecture already!! Let's start by looking at how we
can play a sequence of notes. First, let's implement a simple
iterative process. Remember that 60 is middle C, 61 is C#, 62 is D
etc...
 
#+begin_src extempore
;; iterative sequence
(dotimes (i 8)
   (play-note (+ (now) (* i 5000)) piano (+ 60 i) 80 4000))
#+end_src
 
Simple enough. But there is a problem here. we don't have any control
over dotimes iterator i. What if we want to play a whole tone scale.
Let's use recursion to try to solve this problem. Ok all you scheme
newbies it's time time find out about named lets :)
 
#+begin_src extempore
;; recursive whole-tone scale
(let loop ((i 0))
   (play-note (+ (now) (* i 2500)) piano (+ 60 i) 80 4000)
   (if (< i 9) (loop (+ i 2))))
#+end_src
 
I'm sure there are a few people whispering---he could have done that
with dotimes---but this is scheme and well frankly the quicker we move
onto recursion the better ;)
 
So, linear sequences don't seem to present a problem. How about a
major scale. Well, our recursion should handle this for us.
 
#+begin_src extempore
;; recursive major scale
(let loop ((scale '(0 2 4 5 7 9 11 12))
           (time 0))
   (play-note (+ (now) time) piano (+ 60 (car scale)) 80 4000)
   (if (not (null? (cdr scale)))
       (loop (cdr scale) (+ time 5000))))
#+end_src
 
We also added a second argument to loop---time. Let's use that time
argument to add changing durations to our scale.
 
#+begin_src extempore
;; recursive major scale with rhythm
(let loop ((scale '(0 2 4 5 7 9 11 12))
           (dur '(22050 11025 11025 22050 11025 11025 44100 44100))
           (time 0))
   (play-note (+ (now) time) piano (+ 60 (car scale)) 80 (car dur))
   (if (not (null? (cdr scale)))
       (loop (cdr scale) (cdr dur) (+ time (car dur)))))
#+end_src
 
Ok now that we have pitches and rhythms mastered how do we go about
playing a chord. The new time argument from the previous examples
should give you a pretty good clue. Just lose the time argument!
 
#+begin_src extempore
;; recursive chord
(let loop ((chord '(0 4 7)))
   (play-note (now) piano (+ 60 (car chord)) 80 44100)
   (if (not (null? (cdr chord)))
       (loop (cdr chord))))
 
;; we could also write this
(let loop ((scale '(0 4 7)))
   (cond ((null? scale) 'finished)
         (else (play-note (now) piano (+ 60 (car scale)) 80 44100)
               (loop (cdr scale)))))
#+end_src
 
C Major, nice! We seem to be using lists a lot and I know that all you
newbie scheme programmers are just dying to use map so here goes.
 
#+begin_src extempore
;; map calls lambda for each argument of list
(map (lambda (p)
        (play-note (now) piano p 80 44100))
     (list 60 63 67))
#+end_src
 
Wow, C minor, nice! That's much shorter, why don't we always use map.
There are a couple of reasons why sometimes it's better not to use map
but we'll come to those soon enough. For the moment let's look at how
we can use map to play a broken chord.
 
#+begin_src extempore
;; map broken chord
(map (lambda (p d)
        (play-note (+ (now) d) piano p 80 (- 88200 d)))
     (list 60 64 67)
     (list 0 22050 44100))
#+end_src
 
One small thing to keep in mind. map is designed to return a new list
of values to you. The process of creating this list makes map slightly
less efficient than the function for-each which is not specified to
return a list but is instead designed for it's side effects (i.e.
playing notes in this instance). So if you don't need to return a list
use for-each instead of map.
 
#+begin_src extempore
;; for-each broken chord with volumes
(for-each (lambda (p d v)
             (play-note (+ (now) d) piano p v (- 88200 d)))
          (list 60 64 67)
          (list 0 22050 44100)
          (list 90 50 20))
#+end_src
 
Ok, now we've covered the basics before we move on if you haven't read
the time tutorial it's time to go and read it now.

Ok, hopefully you've had a peek at the time tutorial and you're all
set for callbacks. In The Basics we looked at various ways to play a
sequence of notes. We're now going to expand on that theme. Let's
define a function that uses callback to temporally recurse through a
list of pitch values.
 
#+begin_src extempore
;; plays a sequence of pitches
(define play-seq
   (lambda (time plst)
      (play-note time piano (car plst) 80 11025)
      (if (not (null? (cdr plst)))
          (callback (+ time 10000) 'play-seq (+ time 11025) (cdr plst)))))
 
(play-seq (now) '(60 62 63 65 67 68 71 72))
#+end_src
 
This should look very similar to the examples in The Basics. Now let's
change play-seq to enable it to repeat the sequence indefinitely.
 
#+begin_src extempore
;; plays a sequence of pitches indefinitely
(define play-seq
   (lambda (time plst)
      (play-note time piano (car plst) 80 11025)
      (if (null? (cdr plst))
          (callback (+ time 10000) 'play-seq (+ time 11025) '(60 62 65))
          (callback (+ time 10000) 'play-seq (+ time 11025) (cdr plst)))))
 
(play-seq (now) '(60 62 65))
#+end_src
 
Ok, now while play-seq is running change the '(60 62 65) in play-seq
to '(60 62 67) and re-evaluate the play-seq function. Now try changing
it to '(60 62 67 69) and re-evaluating. Because play-seq uses this
list to reinitialize plst whenever plst is null any changes we make
are reflected when this re-initialization occurs. A useful little
trick. Stop the play-seq function by re-defining play-seq to be the
function that does nothing (define play-seq (lambda args)).
 
Let's extend play-seq to include a rhythm list as well.
 
#+begin_src extempore
;; plays a sequence of pitches
(define play-seq
   (lambda (time plst rlst)
      (play-note time piano (car plst) 80 (car rlst))
      (callback (+ time (* .5 (car rlst))) 'play-seq (+ time (car rlst))
                (if (null? (cdr plst))
                    '(60 62 65 69 67)
                    (cdr plst))
                (if (null? (cdr rlst))
                    '(11025 11025 22050 11025)
                    (cdr rlst)))))
 
(play-seq (now) '(60 62 65 69 67) '(11025 11025 22050 11025))
#+end_src 
 
Note that our pitch list and our rhythm list are different lengths.
Unlike for-each (and map) we can iterate through these two lists
independently---meaning they can be of different lengths which allows
us to play with various phasing techniques. Have a play, change the
lengths/values of both lists inside the play-seq function---remember
to re-evaluate play-seq when you are ready for your changes to take
effect. Try calling play-seq again to start a second sequence playing.
Try to create a nice offset---you'll need to press ctrl-space at just
the right time :-) Note that after the first iteration through the
sequence both running instances of play-seq will assume the same lists
(because callback sets the same list values when it's time to
reinitialize the lists). As an exercise for the reader, think about
how you could avoid that problem (i.e. keep the lists independent for
each instance of play-seq).
 
Ok, so we can now manually change the list each cycle through, but
what if we would like to change the list programmatically. No problem,
just you use a function instead of a literal list---of course this is
now no longer an ostanati!
 
#+begin_src extempore
;; plays a random pentatonic sequence of notes
(define play-seq
   (lambda (time plst rlst)
      (play-note time piano (car plst) 80 (* .65 (car rlst)))
      (callback (+ time (* .5 (car rlst))) 'play-seq (+ time (car rlst))
                (if (null? (cdr plst))
                    (make-list-with-proc 4 (lambda (i) (random '(60 62 64 67 69))))
                    (cdr plst))
                (if (null? (cdr rlst))
                    (make-list 4 11025)
                    (cdr rlst)))))
 
(play-seq (now) '(60 62 64 67) '(11025))
#+end_src
 
One final thing before we move on. Just a quick performance tip
(musical performance of course!). It is very easy to add some metric
interest by oscillating the volume to peak on down beats. Let's make a
small modification to the previous example to demonstrate this simple
little cheat ;) Also we'll shorten the durations a little (constant
legato gets a touch boring).
 
#+begin_src extempore
;; plays a random pentatonic sequence of notes with a metric pulse
(define play-seq
   (lambda (time plst rlst)
      (play-note time piano (car plst)
                      (+ 60 (* 50 (cos (* 0.03125 3.141592 time))))
                      (* .65 (car rlst)))
      (callback (+ time (* .5 (car rlst))) 'play-seq (+ time (car rlst))
                (if (null? (cdr plst))
                    (make-list-with-proc 4 (lambda (i) (random '(60 62 64 67 69))))
                    (cdr plst))
                (if (null? (cdr rlst))
                    (make-list 4 11025)
                    (cdr rlst)))))
 
(play-seq (now) '(60 62 64 67) '(11025))
#+end_src

If you read many 20thC composition texts on pitch classes you could be
forgiven for thinking pitch class sets a rather dry subject and of
limited compositional value. Oh, how wrong you would be! Pitch classes
are fantastically useful for the music programmer and trivial to
understand and use effectively.
 
A brief reminder (or introduction for those unfamiliar with pitch
classes). Pitch classes are based around the 12 semitones of the
chromatic scale where each semitone is given it's own class. C C# D
D#/Eb F F# etc. Now remove all octave reference and enharmonic
signature, we talk about pitch classes as having enharmonic and octave
equivalence (i.e. D#/Eb are the same pitch class in any octave). Of
course in a programming space we use numbers to represent pitches
(because numbers are easier for us to work with---which is why
Extempore does not by default include pitch symbols) so instead of
B#/C/Db for example we use 0, C#/Db is 1, D is 2 ... through to
A#/B/Cb at 11 which rounds out the complete set of available pitch
classes 0-11.
 
Now, the observant reader will note that we can use modulo arithmetic
to find midi pitches of octave equivalence by using mod 12. Try
running this example (check the log view for results).
 
#+begin_src extempore
(dotimes (i 12)
   (print 'modulo (+ i 60) 12 '=> (modulo (+ i 60) 12)))
#+end_src
 
Ok so that has to be useful right! It sure is. Now as previously
discussed, Extempore does not include much in-built musical support,
however, there is a libraries page and on that page you will find
pc-lib.scm. You'll need to download that file before proceeding. I
encourage you to take a look at the pc-lib.scm file and extend and
replace things as you see fit (you'll probably find that you can do a
better job than I have :-)
 
Let's start with something simple. We can define a pitch class set by
creating a list of pitch classes that belong to the set. We can then
test a pitch against that set by using pc:?
 
#+begin_src extempore
;; four examples tested against the pitch class set representation of a c major chord
(pc:? 60 '(0 4 7))
(pc:? 84 '(0 4 7))
(pc:? 35 '(0 4 7))
(pc:? 79 '(0 4 7))
#+end_src
 
We can also choose a random number between a lower and upper bounds
from a pitch class set.
 
#+begin_src extempore
;; this chooses a C in any octave
(pc:random 0 127 '(0))
 
;; this chooses any note from a dminor chord in octave 4
(pc:random 60 73 '(2 5 9))
 
;; this chooses any note from a c pentatonic octaves 3-6
(pc:random 48 97 '(0 2 4 7 9))
#+end_src
 
Let's write a little organum piece (how 13C of me) We're going to
write a strict parallel organum where we take a melody part and then
transpose up a perfect forth or fifth (you can try both) to supply a
harmony. So why is this in the PC section, well you can't just
transpose up a fifth by adding 7 to everything. Why not you ask, take
a look.
 
#+begin_src extempore
;; up 7 semitones or a perfect fifth
(map (lambda (p)
        (pc:? (+ p 7) '(0 2 4 5 7 9 11)))
     (list 60 62 64 65 67 69 71))
 
;; up 5 semitones or a perfect forth
(map (lambda (p)
        (pc:? (+ p 5) '(0 2 4 5 7 9 11)))
     (list 60 62 64 65 67 69 71))
 
;; up 4 semitones or a major third
(map (lambda (p)
        (pc:? (+ p 4) '(0 2 4 5 7 9 11)))
     (list 60 62 64 65 67 69 71))
#+end_src

Based on a C-major key pitch class set => B up 7 semitones (a perfect
5th) gives us F#. F up by 5 semitones (a perfect 4th) gives Bb and if
we have the audacity to try 4 semitones (a major 3rd)---well basically
nothing works. Notice that we do use map here instead of for-each
because we do want to return a list (of boolean values). So the answer
is to use pc:relative which will choose a pitch value from the pitch
class relative to our current pitch.
 
#+begin_src extempore
;; this gives us 62
(pc:relative 60 1 '(0 2 4 5 7 9 11))
 
;; this gives us 67
(pc:relative 60 4 '(0 2 4 5 7 9 11))
 
;; this gives us 67 as well
(pc:relative 67 0 '(0 2 4 5 7 9 11))
 
;; this gives us 57 (yes you can go backwards)
(pc:relative 60 -2 '(0 2 4 5 7 9 11))
#+end_src
 
On with the organum. Oh, one more rule, we need our melody and harmony
to start and finish on the same note---C. Here's one way we could go
about the task.
 
#+begin_src extempore
;; define a melody
(define melody (make-list-with-proc 24
                                    (lambda (i)
                                       (pc:random 60 73 '(0 2 4 5 7 9 11)))))
 
;; define harmony up a perfect 5th (4 places away in the pitch class set)
(define harmony (map (lambda (p)
                        (pc:relative p 4 '(0 2 4 5 7 9 11)))
                     melody))
 
;; set c at start and end
(set! melody (cons 60 melody))
(set! harmony (cons 60 harmony))
(set! melody (reverse (cons 60 (reverse melody))))
(set! harmony (reverse (cons 60 (reverse harmony))))
 
;; random rhythm
(define rhythm (make-list-with-proc 24 (lambda (i) (random '(44100 22050)))))
 
;; set long start and end to rhythm
(set! rhythm (cons 88200 rhythm))
(set! rhythm (reverse (cons 88200 (reverse rhythm))))
 
(define organum
   (lambda (time mlst hlst rlst)
      (play-note time piano (car mlst) 60 (car rlst))
      (play-note time piano (car hlst) 60 (car rlst))
      (if (not (null? (cdr mlst)))
          (callback (+ time (* .5 (car rlst))) 'organum (+ time (car rlst))
                    (cdr mlst)
                    (cdr hlst)
                    (cdr rlst)))))
 
;; start
(organum (now) melody harmony rhythm)
#+end_src
 
Here's what my organum sounds like organum.mp3. It was also a little
out of character for the melody to leap around so much so let's also
use pc:relative to implement a random walk melody (the rest of your
code can stay the same but remember to reevaluate everything that the
change effects---everything to do with creating melody and harmony).
 
#+begin_src extempore
;; define a random walk melody seeded with 60 (we remove this at the end with cdr)
(define melody (let loop ((i 0)
                          (lst '(60)))
                  (if (< i 24)
                      (loop (+ i 1)
                            (cons (pc:relative (car lst)
                                               (random '(-1 1))                                              
                                               '(0 2 4 5 7 9 11))
                                  lst))
                      (cdr (reverse lst)))))
#+end_src
 
Of course we could easily use larger leaps by changing (random '(-1
1)) to (random '(-2 -1 1 2 3) for example. pc-relative can be a useful
way of constraining (and then later releasing) melodic invention.
 
Ok, that's enough 13thC hip hop, let's go hard core 20thC and make a I
IV V progression :) But first a crazy 21stC chord. Once crazy-chord is
running, slowly start removing pitch classes from the end of the set
(I'm not going to remind you to re-evaluate anymore :-) and listen to
the c-major chord that starts to evolve. If your machine will handle a
higher callback rate then go for it, we're after a wash of sound here.
Try choosing a sound with a delay for extra impact (don't let my piano
symbol fool you ;)
 
#+begin_src extempore
(define crazy-chord
   (lambda (time)
      (play-note time piano (pc:random 24 97 '(0 4 7 10 2 3 5 9 6 11 1)) 80 500)
      (callback (+ time 1000) 'crazy-chord (+ time 2000))))
 
(crazy-chord (now))
#+end_src
 
Here's a recording of my machine going absolutely gang-busters until
it finally resolves to the last pitch class 0 (c). crazy-chord.mp3
 
Ok, so we've seen how we can use a pitch class to represent a chord.
pc-lib also includes a useful little function pc:make-chord for
returning a 'random' chord based on a pitch class set. Let's take a
look at this in action.
 
#+begin_src extempore
;; C-major and repeat
(define chords
   (lambda (time)
      (for-each (lambda (p)                  
                   (play-note time piano p 80 10000))
                (pc:make-chord 60 72 3 '(0 4 7)))
      (callback (+ time 10000) 'chords (+ time 11025))))
 
(chords (now))
#+end_src 
 
Hey, our friend for-each is back. Now while this is playing start
expanding the range (i.e. drop the 60 down and raise the 72 up).
pc:make-chord returns as many notes as we request (3 in this example)
from the pitch class and it tries to evenly distribute the number of
notes across the chosen range. It also attempts to use each class in
the pitch class set. However, it does not make any guarantees about
what order to choose classes from the pitch class set (i.e. i i6 i64
are all possible in this example). You might also like to change the
number of notes being generated for our chord---try changing 3 to 1
now try 2, 4, 5 etc..
 
Getting a little sick of C-major, let's add IV (f major) and V (g
major) to the progression and make a random chord change one in five
callbacks. Note that random can just as easily choose a list from a
list as an atom from a list.
 
#+begin_src extempore
;; I IV V
(define chords
   (lambda (time chord)
      (for-each (lambda (p)                  
                   (play-note time piano p 80 10000))
                (pc:make-chord 48 90 3 chord))
      (callback (+ time 10000) 'chords (+ time 11025)
                (if (> (random) .8)
                    (random '((0 4 7) (5 9 0) (7 11 2)))
                    chord))))
 
(chords (now) '(0 4 7))
#+end_src
 
Here's what this sounds like on my machine. chords.mp3 There's a lot
more we can do with pitch classes so go and explore, we'll also see
plenty more examples in the coming pages.
 
Time to move onto some serious composition, and what could be more
serious than diatonic harmony ;)

Now everyone knows that you don't follow V with ii, at least this is
probably what your music teacher tried to tell you ;) 18thC Harmony
lessons aside this point does question the validity of calling random
chord changes a progression.
 
A russian mathematician named Andrey Markov came up with one neat
solution which we're going to pinch (he was actually interested in
russian language usage, but hey whatever). His work stated that you
can construct a probability matrix that outlines the probability of
any new state occurring based on a current state.
 
So let's look at a very traditional picture (for simplicity's sake) of
Western Diatonic Harmony. Remembering that in the major key our scale
degree's give us the following chords I-ii-iii-IV-V-vi-viio where
roman uppercase are major chords, roman lowercase are minor chords and
viio is a diminished chord. When we add the circle of 5ths into the
mix, we end up with a chord progression chart that in it's simplest
form looks something like this (I've taken a few liberties based on a
few hundred years of usage).
  
So reading this diagram from left to right we can move from iii to vi.
Then from vi to either IV or ii. From IV we can then move to either
viio, ii, V or I. From ii we can move to either viio or V. From viio
we can move to V or I. From V we can move to either vi or I. And from
I we can move anywhere---however in the matrix to the right I have
limited I's movement to iii IV V and vi. This is a pretty limited view
of the harmonic world but we'll stick with it for today.
 
Now for the cool part. We can use random and assoc to trivially
implement this markov matrix in Extempore (if you don't know what
assoc does go and quickly check your favorite scheme book). For this
first effort we're going to assume the key of C major and I'm going to
limit the example to the I, IV and V chords only.
 
#+begin_src extempore
;; markov chord progression I IV V
(define progression
   (lambda (time chord)
      (for-each (lambda (p)
                   (play-note time piano p 80 40000))
                (pc:make-chord 60 73 3 chord))
      (callback (+ time 40000) 'progression (+ time 44100)
                (random (cdr (assoc chord '(((0 4 7) (5 9 0) (7 11 2))
                                            ((5 9 0) (7 11 2) (0 4 7))
                                            ((7 11 2) (0 4 7)))))))))
 
(progression (now) '(0 4 7))
#+end_src
 
Now that was pretty easy but our list of chords is a little unwieldy.
Fortunately pc-lib has a function that will help us out with that
problem. pc:diatonic is designed to return a chords pitch class given
a key and a scale degree. So if we use (pc:diatonic 0 '^ 'iii) we are
asking for iii in the key of c (0) major ('^). '^ is major and '- is
minor. Because Extempore symbols are lowercase only we use 'i for I 'v
for V etc. Because pc:diatonic is passed major or minor it is clever
enough to know that 'i means I and that 'vii means viio in the major
key. In minor 'i will be minor etc.. Let's look at an example that
implements our entire matrix.
 
#+begin_src extempore
;; markov chord progression I ii iii IV V vi vii
(define progression
   (lambda (time degree)
      (for-each (lambda (p)
                   (play-note time piano p 80 40000))
                (pc:make-chord 48 77 5 (pc:diatonic 0 '^ degree)))
      (callback (+ time 40000) 'progression (+ time 44100)
                (random (cdr (assoc degree '((i iv v iii vi)
                                             (ii v vii)
                                             (iii vi)
                                             (iv v ii vii i)                                            
                                             (v i vi)
                                             (vii v i)
                                             (vi ii))))))))
 
(progression (now) 'i)
#+end_src
 
Have a listen to my progression progression_one.mp3. Let's try playing
this on a harpsichord. But first we're going to add a couple of
performance changes (1) we'll randomly add mordants and (2) make I and
IV twice the duration of the other chords.
 
#+begin_src extempore
;; mordant  
(define play-note-mord
   (lambda (time inst pitch vol duration pc)
      (play-note (- time 5000) inst pitch (- vol 10) 2500)
      (play-note (- time 2500) inst (pc:relative pitch 1 pc) (- vol 10) 2500)
      (play-note time inst pitch vol (- duration 5000))))

;; markov chord progression I ii iii IV V vi vii
(define progression
   (lambda (time degree)
      (let ((dur (if (member degree '(i iv)) 88200 44100)))
         (for-each (lambda (p)
                      (if (and (> p 70) (> (random) .7))
                          (play-note-mord time piano p
                                          (random 70 80)
                                          (* .9 dur) '(0 2 4 5 7 9 11))                  
                          (play-note time harpsichord p (random 70 80) (* .9 dur))))
                   (pc:make-chord 40 78 4 (pc:diatonic 0 '^ degree)))
         (callback (+ time (* .9 dur)) 'progression (+ time dur)
                   (random (cdr (assoc degree '((i iv v iii vi)
                                                (ii v vii)
                                                (iii vi)
                                                (iv v ii vii i)                                            
                                                (v i vi)
                                                (vii v i)
                                                (vi ii)))))))))
 
(progression (now) 'i)
#+end_src
 
And here's a recording of the harpsichord in action
progression_two.mp3. Not bad!
 
Ok so, as a final exercise let's try to make a simple ditty for
woodwind quintet. We're going to need 5 parts and we should try to
have some simple part movement (i.e. not just block chords
everywhere). Now to do this, we're going to cheat and use pc:relative
to move from our chord tones on off beats, Arnold Schoenberg would be
most unpleased!! The other thing we're going to have to do is assign
the right instrument to the right part. I'm playing my instruments on
the same audiounit but using different midi-channels for each
instrument. We'll also add an even longer duration option for I and
IV. Let's take a look at how this might look.
 
#+begin_src extempore
;; Wind Quintet
 
(define flute 0)
(define oboe 1)
(define clarinet 2)
(define horn 3)
(define bassoon 4)
 
(define progression
   (lambda (time degree)
      (let ((dur (if (member degree '(i iv)) (random (list 88200 (* 2 88200))) 44100)))
         (for-each (lambda (p inst)
                      (cond ((and (> (random) .7) (< dur 80000))
                             (play-note time sampler p (random 60 70) (* .3 dur) inst)
                             (play-note (+ time (* .5 dur)) sampler
                                        (pc:relative p (random '(-1 1))
                                                     '(0 2 4 5 7 9 11))
                                        (random 60 80)
                                        (* .3 dur) inst))
                            (else (play-note time sampler p
                                             (random 60 70)
                                             (* .7 dur)
                                             inst))))
                   (pc:make-chord 36 90 5 (pc:diatonic 0 '^ degree))
                   (list bassoon horn clarinet oboe flute))
         (callback (+ time (* .8 dur)) 'progression (+ time dur)
                   (random (cdr (assoc degree '((i iv v iii vi)
                                                (ii v vii)
                                                (iii vi)
                                                (iv v ii vii i)                                            
                                                (v i vi)
                                                (vii v i)
                                                (vi ii)))))))))
 
(progression (now) 'i)
#+end_src
 
Wind Quintet Number 1. By Extempore progression_three.mp3 Bring back
the beat I hear you say. OK, onto Beat & Tempo.

So far we have been using Extempore's default time standard, samples
per second, to control rhythm and duration information. As musicians
though, we are more used to working with beats and tempo. Here's a
simple example working with samples. Note that throughout this
tutorial I'm using gm drums (with the DLS instrument) and passing
midi-channel 10 (9) to the play-note function. At the end of this page
you'll find a list of general midi drum definitions which I'll be
using in this tutorial---for *gm:maracas* etc..
 
#+begin_src extempore
;; samples per second loop
(define drum-loop
   (lambda (time dur)
      (play-note time drums *gm:maracas* 80 dur 9)
      (callback (+ time (* .5 dur)) 'drum-loop (+ time dur) (random '(22050 11025)))))
 
(drum-loop (now) 11025)
#+end_src
 
And here's one way that we could go about transforming this into a
more abstract notion of time.
 
#+begin_src extempore
;; beat loop
(define drum-loop
   (lambda (time dur)
      (let ((d (* dur *samplerate*)))
         (play-note time drums *gm:maracas* 80 d 9)
         (callback (+ time (* .5 d)) 'drum-loop (+ time d) (random '(0.5 0.25))))))
 
(drum-loop (now) 0.25)
#+end_src
 
So what's the advantage here---this seems like more work for nothing?
Well, we actually gain two big advantages. (1) Ratio's are easier to
deal with than samples---0.25 is easier to remember than 11025
(assuming a samplerate of 44100) (2) this system supports alternate
tempos---we can change tempo without having to change any rhythm
values.
 
Let's play back the same example at 120 bpm---remembering that by
default Extempore runs at 60 bpm or 1.0 = *samplerate*. We'll also add
triplets to our quavers and semi-quavers.
 
#+begin_src extempore
;; beat loop at 120bpm
(define drum-loop
   (lambda (time dur)
      (let ((d (* dur .5 *samplerate*)))
         (play-note time drums *gm:maracas* 80 d 9)
         (callback (+ time (* .5 d)) 'drum-loop (+ time d)
                   (random (list (/ 1 3) 0.5 0.25))))))
 
(drum-loop (now) 0.25)
#+end_src
 
Let's try using an oscillator to drift the playback speed back and
forth over time.
 
#+begin_src extempore
;; beat loop with tempo shift
(define drum-loop
   (lambda (time dur)
      (let ((d (* dur (+ .5 (* .25 (cos (* 16 3.141592 time)))) *samplerate*)))
         (play-note time drums *gm:maracas* 80 d 9)
         (callback (+ time (* .5 d)) 'drum-loop (+ time d)
                   (random (list 0.5))))))
 
(drum-loop (now) 0.5)
#+end_src
 
Have a listen to the result on my machine---note that all values are
now 0.5 so we should get a nice even rhythm with a tempo change over
time drums_one.mp3. Doesn't sound very even does it! It turns out that
tempo is a lot more subtle than you might expect. What we actually
need is a linear function that can more evenly distribute our beats
with respect to tempo changes. Luckily the impromprtu library
time-lib.scm will do this for us.
 
As it turns out time-lib.scm includes a function called make-metro
that will solve a few problems for us. At it's simplest, make-metro is
a function that accepts a tempo and returns a closure to us. We can
then call that closure with a cumulative time in beats and have an
absolute sample number returned to us. This makes more sense as a
practical exercise so let me demonstrate.
 
#+begin_src extempore
;; create a metronome starting at 120 bpm
(define *metro* (make-metro 120))
 
;; beat loop
(define drum-loop
   (lambda (time duration)
      (print time duration)
      (play-note (*metro* time) drums *gm:maracas* 80 (*metro* 'dur duration) 9)
      (callback (*metro* (+ time (* .5 duration))) 'drum-loop (+ time duration)
                (random (list 0.5)))))
 
(drum-loop (*metro* 'get-beat) 0.5)
#+end_src 
 
You should notice a couple of things here:
 
1. We start our loop by calling (*metro* 'get-beat). This asks our
   *metro* closure to return the next available beat number to us
   (i.e. fmod 1.0)---*metro* starts ticking over beats as soon as it's
   initalized (actually this is not really true---*metro* is a linear
   function---but it is easier to think about it this way).
2. time is now in beats (not in samples) and is cumulative. Check your
   logview for an idea about what time equals each cycle around
   drum-loop. Also remember that floating point is subject to rounding
   error---don't worry about that overly.
3. (*metro* 'dur duration) returns a duration in samples relative to
   the current tempo.
4. The closure returned by (make-metro) is really a kind of object and
   the symbol names are method names---message names really. Any
   arguments after the "message name" are passed with the "message"
   are dispatched inside the closure to the appropriate "method". What
   we are using here is a form of message passing. Who said scheme
   wasn't an OO language!!
 
OK now how about those tempo changes. No problem, we just need to use
another message 'set-tempo which takes a new tempo in bpm (beats per
minute).
 
#+begin_src extempore
;; create a metronome starting at 120 bpm
(define *metro* (make-metro 120))
 
;; beat loop with tempo shift
(define drum-loop
   (lambda (time duration)
      (*metro* 'set-tempo (+ 120 (* 40 (cos (* .25 3.141592 time)))))
      (play-note (*metro* time) drums *gm:maracas* 80 (*metro* 'dur duration) 9)
      (callback (*metro* (+ time (* .5 duration))) 'drum-loop (+ time duration)
                (random (list 0.5)))))
 
(drum-loop (*metro* 'get-beat) 0.5)
#+end_src
 
And here's what it sounds like drums_two.mp3. Much better, I'm sure
you will agree. Now the really cool thing about *metro* is that you
can now use it to sync as many callback loops as you like. Let's add a
second drum-loop call. Notice also that we have added an argument to
the 'get-beat message that asks 'get-beat to quantize to a 4.0 (i.e.
four beats) instead of the default 1.0. I'm going to play maracas and
tambourine with a slight 0.25 offset.
 
#+begin_src extempore
;; create a metronome starting at 120 bpm
(define *metro* (make-metro 120))
 
;; beat loop with tempo shift
(define drum-loop
   (lambda (time duration pitch)
      (play-note (*metro* time) drums pitch 80 (*metro* 'dur duration) 9)
      (callback (*metro* (+ time (* .5 duration))) 'drum-loop (+ time duration)
                duration
                pitch)))
 
;; shift tempo over time using oscillator
(define tempo-shift
   (lambda (time)
      (*metro* 'set-tempo (+ 120 (* 40 (cos (* .25 3.141592 time)))))
      (callback (*metro* (+ time .2)) 'tempo-shift (+ time .25))))
 
(drum-loop (*metro* 'get-beat 4) 0.5 *gm:maracas*)
(drum-loop (*metro* 'get-beat 4.25) 0.5 *gm:tambourine*)
(tempo-shift (*metro* 'get-beat 1.0))
#+end_src
 
And it sounds like this drums_three.mp3 Ahhh, like clockwork. Notice
that now we are running two independent drum-loop temporal callbacks
we need to put the tempo shift in a separate function---we don't want
the tempo to be set independently by two seperate loops!
 
We now have almost enough information to build our first drum machine!

The time-lib library also contains a very useful function called
make-metre. Like the make-metro function, the make-metre function
returns a closure which can subsequently be called. make-metre returns
a closure that returns #t or #f based on a simple query---given an
accumulated beat are we on a certain metric pulse? A practical demo
should make this a little clearer.
 
First though, a brief explanation of make-metre initial arguments.
First argument is a list of numerators and the second argument is a
single denominator. What this implies is that make-metre can work with
a series of revolving metre's. For example, (make-metre '(4) 1.0)
gives us 4 * 1.0 metric pulses (recurring 4/4 bars); (make-metre '(3)
0.5) gives us 3 * 0.5 metric pulses (recurring 3/8 bars); (make-metre
'(2 3) 0.5) gives us 2 * 0.5 then 3 * 0.5 metric pulses (recurring
series of 2/8 3/8 2/8 3/8 2/8 3/8 ... ).
 
Let's try an example. Note that we are only going to play the first
beat of each 'bar'.
 
#+begin_src extempore
(define *metro* (make-metro 90))
 
;; a 2/8 3/8 2/8 cycle
(define *metre* (make-metre '(2 3 2) 0.5))
 
;; play first beat of each 'bar'
(define metre-test
   (lambda (time)
      (if (*metre* time 1.0)
          (play-note (*metro* time) drums *gm:side-stick* 80 10000 9))
      (callback (*metro* (+ time 0.4)) 'metre-test (+ time 0.5))))
 
(metre-test (*metro* 'get-beat 1.0))
#+end_src
 
Well that was easy. Let's complicate things just a little by adding a
second metre. We'll play the side stick for one metre and the snare
for the second metre.
 
#+begin_src extempore
;; classic 2 against 3
;;
 
(define *metro* (make-metro 180))
 
;; 3/8
(define *metre1* (make-metre '(3) .5))
;; 2/8
(define *metre2* (make-metre '(2) .5))
 
 
;; play first beat of each 'bar'
(define metre-test
   (lambda (time)
      (if (*metre1* time 1.0)
          (play-note (*metro* time) drums *gm:side-stick* 80 10000 9))
      (if (*metre2* time 1.0)
          (play-note (*metro* time) drums *gm:snare* 60 10000 9))
      (callback (*metro* (+ time 0.4)) 'metre-test (+ time 0.5))))
 
(metre-test (*metro* 'get-beat 1.0))
#+end_src
 
The French composer Olivier Messiaen is well known for (amongst many
things) symmetrical metric structures. Let's take his lead and build
up a relatively complex poly-symmetric drum pattern. Again we're are
going to work with two (poly) competing metric structures---both of
which will be symmetric ( 2/8 3/8 4/8 3/8 2/8 ) and (3/8 5/8 7/8 5/8
3/8). Note that because the second metric structure is uneven in
length we should get some nice phasing effects (a la Steve Reich). I'm
also going to add some hi-hats to give it a constant pulse.
 
#+begin_src extempore
;; messiaen drum kit
(define *metro* (make-metro 140))
 
(define *metre1* (make-metre '(2 3 4 3 2) .5))
(define *metre2* (make-metre '(3 5 7 5 3) .5))
 
;; play first beat of each 'bar'
(define metre-test
   (lambda (time)
      (play-note (*metro* time) drums
                 (random (cons .8 *gm:closed-hi-hat*) (cons .2 *gm:open-hi-hat*))
                 (+ 40 (* 20 (cos (* 2 3.441592 time))))                
                 (random (cons .8 500)  (cons .2 2000)) 9)
      (if (*metre1* time 1.0)
          (begin (play-note (*metro* time) drums *gm:snare* 80 10000 9)
                 (play-note (*metro* time) drums *gm:pedal-hi-hat* 80 100000 9)))        
      (if (*metre2* time 1.0)
          (begin (play-note (*metro* time) drums *gm:kick* 80 100000 9)
                 (play-note (*metro* time) drums *gm:ride-bell* 100 100000 9)))
      (callback (*metro* (+ time 0.2)) 'metre-test (+ time 0.25))))
 
(metre-test (*metro* 'get-beat 1.0))
#+end_src
 
Here's a short recording kit_one.mp3---I'm not sure what Messiaen
would think of this :)
 
There are a couple of things to note in the previous example. First
our old oscillating volume is back in the hi-hat parts. We are also
using a weighted random for the first time for both the choice of
hi-hat pitch and the length of the hi-hat sound. Also notice that we
are moving around our callback faster than before---but this does not
affect our metre's as long as our time increment has a suitable ratio
to both metre's.
 
Let's keep going with this idea and add bass, bells and keyboard parts
to accentuate the pattern.
 
#+begin_src extempore
;; messiaen drum kit
(define *metro* (make-metro 140))
(au:set-global-tempo 140)
 
(define *metre1* (make-metre '(2 3 4 3 2) .5))
(define *metre2* (make-metre '(3 5 7 5 3) .5))
 
;; play first beat of each 'bar'
(define metre-test
   (lambda (time degree)
      (play-note (*metro* time) drums
                 (random (cons .8 *gm:closed-hi-hat*) (cons .2 *gm:open-hi-hat*))
                 (+ 40 (* 20 (cos (* 2 3.141592 time))))                
                 (random (cons .8 500)  (cons 2 2000))
                 9)
      (play-note (*metro* time) bells
                 (pc:random 90 107 (pc:diatonic 9 '- degree))
                 (+ 50 (* 25 (cos (* .125 3.141592 time))))
                 100)
      (if (*metre1* time 1.0)
          (begin (play-note (*metro* time) drums *gm:snare* 80 10000 9)
                 (play-note (*metro* time) drums *gm:pedal-hi-hat* 80 100000 9)
                 (play-note (*metro* time) bass
                            (+ 60 (car (pc:diatonic 9 '- degree)))
                            60
                            10000)))
      (if (*metre2* time 1.0)
          (begin (play-note (*metro* time) drums *gm:kick* 100 100000 9)
                 (play-note (*metro* time) drums *gm:ride-bell* 100 100000 9)
                 (for-each (lambda (p)
                              (play-note (*metro* time) keys p 70 10000))
                           (pc:make-chord 65 80 3 (pc:diatonic 9 '- degree)))))
      (callback (*metro* (+ time 0.2)) 'metre-test (+ time 0.25)
                (if (= 0.0 (fmod time 8.0))
                    (random (cdr (assoc degree '((i vii vii vi)
                                                 (n v)
                                                 (vi n)
                                                 (v vi i)
                                                 (vii i)))))
                    degree))))
 
(metre-test (*metro* 'get-beat 1.0) 'i)
#+end_src
 
Here is a short example from my machine kit_two.mp3. In this example
we have used many of the techniques picked up in previous tutorials,
so take some time and have a good look through this code. There are
plenty of things here for you to further extend and try out on your
own.
 
We are now going to take a look at how we can control parameter
changes over time.  Or are we?

[fn:quarter-tone] Of course this is a somewhat ridiculous statement
given that straight out of the gate Extempore's use of midi note
numbers for pitches strongly preferences a traditional diatonic tonal
system. Having said that, and as I've shown in [[file:./2012-06-07-dsp-basics-in-extempore.org][other]] [[file:./2012-06-07-more-dsp-and-extempore-types.org][DSP posts]], you
can generate tones of any frequency---quarter tone composers should
not despair!
