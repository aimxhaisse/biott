#+begin_html
---
layout: post
title: "Interacting with the Extempore Compiler"
date: 2012-09-26 13:04
comments: true
categories: 
---
#+end_html

The best way to think about programming and evaluating code in
Extempore is to think of it as a /compiler-as-a-service/ (CaaS). The
compiler (provided by the =extempore= executable) must be running
somewhere, and you connect to it via a TCP socket connection. When the
compiler receives any code (serialised as a string) over this
connection, it compiles and executes it. The general term for this is
'evaluating' the code. There are some nuances to this process, but in
general the programmer interacts with a running Extempore process over
a TCP connection.

The 'chunks' of code which are sent to the xtlang compiler may be
anything from small one-liners to instructions to evaluate whole
source files (via the =load= function). The functions and data which
are evaluated in this way persist for as long as the =extempore=
process is running. As discussed in [[file:~/Documents/biott/org/_posts/2012-08-07-extempore-philosophy.org][this post]], the Extempore compiler
actually compiles /two/ languages: Scheme and xtlang (Extempore's own
programming language).[fn:scm-vs-xtlang]  But the process of
evaluating them is the same---just sending strings to the compiler
over the TCP port.

So, to do anything in Extempore you need a text editor which can
1. open up a TCP connection to the compiler (which by default listens
   on port =7099=)
2. create a string which represents a valid chunk of Scheme or xtlang
   code[fn:philosophy]
3. send that string over the TCP connection

There are lots of text editors which can perform these functions, so
you basically have two options:

- *If you already have a favourite text editor*, then you'll probably
  want to write and evaluate your code using that editor. There are
  already Extempore modes/plugins for [[https://github.com/digego/extempore/blob/master/extras/extempore.el][Emacs]], [[https://github.com/digego/extempore/blob/master/extras/extempore.vim][Vim]] and [[https://github.com/mlozanov/extempore-sublime][Sublime Text 2]].
  If your favourite editor isn't one of those three, then you might
  even have the chops to hack together a plugin yourself---at its most
  basic all it has to do is perform those three functions listed above.

- *If you don't have a favourite text editor* then pick one of the
  ones listed above ([[http://www.gnu.org/software/emacs/][Emacs]], [[http://www.vim.org][Vim]] or [[http://www.sublimetext.com][Sublime Text 2]]). The Emacs
  Extempore mode is the most mature and featureful, but if you don't
  want to deal with the (admittedly daunting) task of learning Emacs
  /as well as/ Extempore, then the ST2 plugin is pretty good as well
  (although ST2 does cost money).

In the end it doesn't matter too much which editor you use, so pick
the one that makes you happiest :)

* Running Extempore

I'm assuming that you've already downloaded and built the Extempore
binary executable (=extempore= on Linux/OSX, =extempore.exe= on
Windows). Once that's done, you can fire up =extempore=. But to do
that, you need to specify an audio device. This is necessary even if
you're not planning to do any audio processing or output, because
Extempore's internal clock is driven by the audio device's
clock.[fn:clock]

But how do we know what audio device to select? Well, the =extempore=
executable provides a handy command-line argument called
=--print-devices=. At a shell prompt, =cd= into the extempore source
directory (where the executable will be) and run

#+begin_html
<a href=""><img src="images/interacting-with-compiler/extempore-print-devices.png" alt=""></a> 
#+end_html

As you can see, running =extempore= with the =--print-devices=
argument prints a list of all the audio devices (input, output and
duplex) that PortAudio can find on the system. On my laptop (as you
can see above) there are five devices: three devices (device index =0=
to =2=) associated with the built-in soundcard, and two more (device
index =3= and =4=) for [[http://code.google.com/p/soundflower/][Soundflower]], which is a utility for routing
audio between different applications. Your computer will probably
print different devices---that's ok.

I want to use the default laptop output, which is =audio device[2]=.
When I run =extempore=, then, I want to pass this device index with
the =--device= argument.  The =--device= argument is optional, if it's
not supplied then Extempore will default to using whatever device is
found at index =0=.  But it's probably a good idea to specify it
explicitly, just to avoid any surprises.

#+begin_html
<a href=""><img src="images/interacting-with-compiler/extempore-start.png" alt=""></a> 
#+end_html

After running =extempore= with device =2=, it prints some information
about the device that it's using. As you can see, it all looks ok: 2
channels out, samplerate of 44100, everthing seems good (and don't
worry too much about the other values for the moment). At this point,
the =extempore= process is running, and will keep doing so until you
kill it.

Also, the compiler prints some information about 'starting up some
processes', namely a =primary= process on port =7099= and a =utility=
process on port =7098=. These are the TCP ports we'll connect to to
send our code over, as discussed at the beginning of this blog post. A
running Extempore binary can provide /multiple/ processes, as well as
connecting to multiple other Extempore processes, potentially running
on remote hosts. This forms the basis for Extempore's powerful
distributed processing capability, which I'll cover in a future blog
post.  For the moment, though, you don't have to worry about multiple
processes, we'll only connect and interact with the =primary= process.

* Connecting to the Extempore compiler

So far, all the stuff we've done has been in a shell console. The
=extempore= process, which provides the Extempore compiler, is just
sitting there, waiting to be given some code to evaluate.  That's
where the text editor part of the equation comes in.

In this post I'm going to be fairly editor-agnostic, because as I
mentioned before as long your editor can open up the TCP connection to
the compiler and send code strings over it, then you're good to go.
In places where there are editor-specific instructions, I'll at least
give instructions for Emacs and ST2.

When you open up a file ending in =.xtm= (Extempore's default file
extension), your editor should detect that you're editing Extempore
source code, and load the appropriate Extempore plugin. Here's a
(short) example file containing some Extempore code:

#+begin_html
<a href=""><img src="images/interacting-with-compiler/text-editor-start.png" alt=""></a> 
#+end_html

The main body of the file is at the top, and I've also included a
representation of the 'echo area' (minibuffer in Emacs terminology).
This is a part of your editor which displays information about the
results of different editor commands, and may also be where the
feedback from the Extempore compiler is 'echoed' (printed out).  It's
blank at the moment.

Now that we have an editor open with some Extempore code (and an
Extempore plugin loaded), and the =extempore= process is still running
from before, we can open up the TCP connection. In Emacs, this is done
with =M-x extempore-connect= (which will also prompt for host and port
arguments). In ST2, use the menu item =Tools > Extempore >
Connect...=.  The default host and port arguments will be =localhost=
and =7099= respectively.  If the connection is made successfully, then
=extempore= will echo back the string ="Welcome to extempore!"=.

* Evaluating code

Once everything's hooked up, then the compiler is just waiting there
for you to give it some code to evaluate. So, from a 'blank slate'
=.xtm= file, let's start with some basic Scheme arithmetic. If you're
playing along, you can write =(+ 1 2)= into your file somewhere.

#+begin_html
<a href=""><img src="images/interacting-with-compiler/scheme-code-input.png" alt=""></a> 
#+end_html

This is where the 'Compiler as a Service' thing starts to get real.
Currently, the code =(+ 1 2)= is just text sitting in your editor. It
won't get compiled until your editor sends it for evaluation. If
you're using Emacs, then the easiest way to do this is to move your
cursor somewhere inside the code =(+ 1 2)= and hit =C-x C-x= (which is
bound to =extempore-send-definition=). In ST2, you can highlight the
code you want to evaluate and either go to =Tools > Extempore >
Evaluate...= or just hit =C-x C-x=. This takes the whole expression
=(+ 1 2)= and sends it (as a string) to the running =extempore=
compiler.

#+begin_html
<a href=""><img src="images/interacting-with-compiler/scheme-eval.png" alt=""></a> 
#+end_html

The 'orange box' in the diagram represents evaluation.  See how the
string (in grey) is sent over the connection, and the result is sent
back (also as a string) and displayed in the echo area.
Congratulations---you've just evaluated your first Extempore code!




If you've read a few of the other blog post on this site about
programming in (with xtlang or Scheme) in Extempore, then you've
probably heard me talk about 'evaluating' code. If you're used to C or
C++ (or any other statically compiled language) this might seem like a
strange notion---code is /compiled/, then it is /executed/. The
compiler produces a static binary (for a given architecture), which
can be distributed and run all over the place. In general, if any
changes are made to the code then the binary has to be re-compiled and
re-distributed.

On the other hand, if you've programmed in a lisp[fn:lisps], or in
some type of scripting language (e.g. perl, ruby or python), then
you've probably seen a read-eval-print-loop (REPL) before. Also called
'interactive' development, in this style of programming you write bits
of code, run them, and have the results printed 'echoed' back to you.
The interpreter for the programming language /reads/ the code that you
give it, /evaluates/ it (carries out the instructions it represents)
and /prints/ the result. These REPL-style environments can be
super-sophisticated,[fn:slime] providing lots of dynamic information
about the state of the interpreters 'world' (often called the
/environment/), i.e. the functions and data that the interpreter has
seen in that programming session and is keeping track of.

* Extempore and the (false) 'static vs dynamic language' dichotomy

If you want to start a flame war on the internets, then just write a
blog post called *Moving from (static language/framework x) to
(dynamic language/framework y) at (company z)*. Bonus angry points if
*company z* is a hot YC-backed startup, and a 10x multiplier if you
mention clojure or node.js. Then you can sit back, watch the hacker
news comment thread deteriorate, and weep for humanity. Ridiculousness
aside, however, the dichotomy is kindof a false one anyway. In reality
it's more of a spectrum, and both ends of the spectrum confer
different advantages and disadvantages. The pertinent question for
this post is /where does Extempore fit along this continuum/?

The answer (as usual) is 'somewhere in the middle.  
* General emacs stuff

Load theme: =M-x load-theme= (then pick from the list)
Open file: =C-x C-f=
Split window horizontally: =C-x 2=
Split window vertically: =C-x 3=
Switch to buffer: =C-x b= (then the name)
Jump to other window (in split window setup): =C-x o=

Beginning of line: =C-a=
End of line of line: =C-e=
Set/unset mark: =C-<space>= (for highlighting)
Kill line: =C-k=

Cancel: C-g (if you get into trouble)
Help (function): =C-h f=, then function name
Help (variable): =C-h v=, then variable name
Info: =C-h i=, then browse through the menus

* Working with Extempore code

1. Start up Extempore in a shell buffer with =M-x shell=
2. Open up an extempore file (.xtm extension)
3. Connect to the running Extempore process: =C-x C-j= (needs to be
   done for /every/ .xtm buffer)

Then, to evaluate (compile) xtlang code, use:

Evaluate enclosing s-expression: =C-x C-x=
Evaluate region: =C-x C-r=
Evaluate whole buffer: =C-x C-b=

To restart the Extempore process, just =C-c C-c= in the *shell* buffer
where it is running to kill it, then start it up again.

[fn:scm-vs-xtlang] There are lots of [[file:~/Documents/biott/org/_posts/2012-08-09-xtlang-type-reference.org][other]] [[file:~/Documents/biott/org/_posts/2012-08-17-memory-management-in-extempore.org][posts]] describing xtlang in
more detail. In this post, I'll just refer to the code generally, only
clarifying whether its Scheme or xtlang when there's a possibility for
confusion.

[fn:clock] This is a good thing: the audio clock will usually be more
stable and accurate than your computer's default system clock,
especially if you're using a dedicated external audio interface.

[fn:lisps] That is, one of the lisp family of languages, e.g. Common
Lisp, Scheme, Clojure, Emacs Lisp, etc.

[fn:slime] Have you /seen/ a lisp hacker using Slime and Emacs?  Wow.
That's some seriously funky stuff.
