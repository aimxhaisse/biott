#+begin_html
---
layout: post
title: "Loading and using a sampler"
date: 2012-10-17 10:18
comments: true
categories:
---
#+end_html

A sampler is an instrument which stores chunks of audio which can be
/triggered/---played back. Samplers are used in many different ways,
such as providing digital simulations of acoustic instruments (e.g. a
piano sampler which plays recorded samples of a /real/ piano when
triggered by messages from a MIDI keyboard) or they can be used to
play and manipulate non-acoustic sounds.

Since samplers are so useful, Extempore provides a built-in sampler in
=libs/external/instruments.xtm=.[fn:external] This sampler basically
works like any other Extempore instrument, such as those described in
the post about todo making an instrument), except that the note kernel
closure is already set up for you---you just have to load the sampler
with sound files. There is also a slight difference in the way we set
a sampler up: using the Scheme macro =define-sampler= instead of
=define-instrument=. The Extempore sampler is still an xtlang closure,
and can be used in all the same situations (e.g. as the =inst=
argument to =play-note= or =play=) as an instrument can.

* Samplers 101

You can think of a sampler as a series of 'slots', each of which
contains a sound file.

#+begin_html
<a href=""><img src="images/sampler/piano-full.png" width="300px" alt=""></a>
#+end_html

Each slot has a unique index, and playing the sampler generally
involves specifying the index of the sample to play, the
loudness/velocity and the duration. There are lots of subtleties to
this process, such as what to do when the duration is longer than the
sample length, what to do if there isn't a sample at the given index,
etc., but at a high level that's how it works. 

If you look at the filenames in each slot (although it's the audio
/data/ in the slots, not the filename strings), you'll notice that
they refer to [[http://en.wikipedia.org/wiki/WAV][wave]] (audio) files named with [[http://en.wikipedia.org/wiki/Scientific_pitch_notation][scientific pitch notation]].
These wave files could be recordings of a piano, or of a violin, or
even of abstract sound effects (although at that point we'd have to
wonder why they were named with pitches from the musical scale).  The
sampler doesn't care what audio data is stored in each slot, and it's
up to you to make sure that both the slot the audio is stored in and
the audio data itself make sense for whatever musical purpose you have
in mind.  

For sampling pitched instruments, using [[http://www.phys.unsw.edu.au/jw/notes.html][MIDI note numbers]] (middle C
= 60) make sense, and that's the convention I've used in the diagram
above.  If you want to trigger the sample for middle C, just use
=play-note= with a pitch argument of =60=.

Now, the Extempore sampler doesn't /have/ to be full---there can be
empty slots.

#+begin_html
<a href=""><img src="images/sampler/piano-gaps.png" width="300px" alt=""></a>
#+end_html

In this instance, when the sampler gets a =play-note= message
corresponding to an empty slot, looks for the closest 'filled' slot,
grabs that audio data, and linearly pitch-shifts it to play at the
required pitch.  

For example, say a message came in to play sample =72= (one octave
above middle C).  If the closest filled slot was middle C (slot =60=),
then the sampler would play the middle C audio file pitch-shifted up
one octave.  If you've ever looked into the maths behind musical
notes, you'll know that for every octave increase in pitch, the
frequency of the waveform doubles.  So, to play a sample /up an
octave/, we play it back at double speed. In practice, because the
audio sample rate is constant, we only play every second sample, which
has the same effect---we're progressing through the audio data twice
as fast.  This is the same reason that when you hit fast-forward on a
tape player (do people still remember tape players) while it's playing
then you get a hilarious chipmunk effect, because everyone's voices
are pitch-shifted up.

If we're not pitch-shifting by a whole octave, then the maths is a bit
trickier (it's not just a matter of doubling the frequency), but
luckily the Extempore sampler takes care of that for us (including all
sorts of fancy stuff like interpolating between individual audio
samples). When a =play-note= calls an empty slot in the sampler, the
pitch-shifting up or down is taken care of, and it (in many cases)
works as though we /did/ have an audio file in that slot.[fn:tempo]

There is the potential for a loss in audio quality the further (in
pitch terms) an audio file has to be shifted. Still, the 'missing
sample interpolation' allows us to make a trade-off between sound
quality and memory footprint.  If sound quality is more important, use
more slots, but if low memory use is more important, use fewer slots
and let the sampler interpolate in the gaps.

* Creating a piano sampler

Let's create an instance of Extempore's sampler called piano. To do
this, we use the =define-sampler= Scheme macro (once we've loaded it
from the =libs/external/instruments.xtm= library file).

#+begin_src extempore
  (load "libs/external/instruments.xtm")
  
  ;; define a sampler (called piano) using the default sampler note kernel and effects
  (define-sampler piano sampler-note-hermite sampler-fx)
  
  ;; add the sampler to the dsp output callback
  (bind-func dsp:DSP
    (lambda (in time chan dat)
      (cond ((< chan 2.0)
             (sampler piano in time chan dat))
            (else 0.0))))
  (dsp:set! dsp)
#+end_src

* Creating a drum sampler

[fn:external] The reason that the sampler is in the =libs/external=
subdirectory instead of the =libs/core= subdirectory like the other
instruments (e.g. the ones covered in todo: these posts) is that
it has an external (non-xtlang) dependency in =libsndfile=.  That's
the difference between =core= and =external=---=core= libs are pure
xtlang code (and should therefore be portable to any architecture the xtlang
compiler runs on) while =external= libs require C shared libraries,
which may or may not be available on a given platform.

[fn:tempo] The exception to this rule is if the audio sample has a
meaningful tempo---such as a full drum loop. In this case, because the
pitch-shifting is also speeding up or slowing down the sample
playback, the tempo will be altered as well. Which may be fine, but it
may also be a problem. If you're in that situation, then you'll
probably want to make sure you have audio data in all the slots you're
going to trigger.
